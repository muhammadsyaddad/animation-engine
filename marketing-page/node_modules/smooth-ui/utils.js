"use strict";

exports.__esModule = true;
exports.calc = exports.resolveUnit = exports.mixin = exports.th = exports.between = exports.down = exports.up = exports.getBreakpointMax = exports.getBreakpointMin = exports.getPreviousBreakpoint = exports.getNextBreakpoint = exports.getBreakpointsEntries = exports.getBreakpoints = void 0;

var _styledComponents = require("styled-components");

var _defaultBreakpoints = _interopRequireDefault(require("./theme/defaultBreakpoints"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject3() {
  var data = _taggedTemplateLiteralLoose(["\n      @media (min-width: ", "px) and (max-width: ", "px) {\n        ", ";\n      }\n    "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteralLoose(["\n    @media (max-width: ", "px) {\n      ", ";\n    }\n  "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["\n    @media (min-width: ", "px) {\n      ", ";\n    }\n  "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

var getBreakpoints = function getBreakpoints(props) {
  return props && props.theme && props.theme.breakpoints || _defaultBreakpoints.default;
};

exports.getBreakpoints = getBreakpoints;

var getBreakpointsEntries = function getBreakpointsEntries(props) {
  var breakpoints = getBreakpoints(props);
  var entries = Object.keys(breakpoints).reduce(function (entries, key) {
    return entries.concat([[key, breakpoints[key]]]);
  }, []);
  return entries.sort(function (a, b) {
    return a[1] > b[1];
  });
};

exports.getBreakpointsEntries = getBreakpointsEntries;

var getNextBreakpoint = function getNextBreakpoint(name, props) {
  var entries = getBreakpointsEntries(props);
  var index = entries.findIndex(function (_ref) {
    var key = _ref[0];
    return key === name;
  });
  return index < entries.length - 1 ? entries[index + 1][0] : null;
};

exports.getNextBreakpoint = getNextBreakpoint;

var getPreviousBreakpoint = function getPreviousBreakpoint(name, props) {
  var entries = getBreakpointsEntries(props);
  var index = entries.findIndex(function (_ref2) {
    var key = _ref2[0];
    return key === name;
  });
  return index >= 1 ? entries[index - 1][0] : null;
};
/**
 * Minimum breakpoint width.
 * Null for the smallest breakpoint.
 */


exports.getPreviousBreakpoint = getPreviousBreakpoint;

var getBreakpointMin = function getBreakpointMin(name, props) {
  var breakpoints = getBreakpoints(props);
  var breakPoint = breakpoints[name];
  return breakPoint !== 0 ? breakPoint : null;
};
/**
 * Maximum breakpoint width. Null for the largest (last) breakpoint.
 * The maximum value is calculated as the minimum of the next one less 0.02px
 * to work around the limitations of `min-` and `max-` prefixes and viewports with fractional widths.
 * See https://www.w3.org/TR/mediaqueries-4/#mq-min-max
 * Uses 0.02px rather than 0.01px to work around a current rounding bug in Safari.
 * See https://bugs.webkit.org/show_bug.cgi?id=178261
 */


exports.getBreakpointMin = getBreakpointMin;

var getBreakpointMax = function getBreakpointMax(name, props) {
  var next = getNextBreakpoint(name, props);
  return next ? getBreakpointMin(next, props) - 0.02 : null;
};

exports.getBreakpointMax = getBreakpointMax;

var up = function up(name, code) {
  return function (props) {
    var value = getBreakpointMin(name, props);
    if (value === null) return code;
    return (0, _styledComponents.css)(_templateObject(), value, code);
  };
};

exports.up = up;

var down = function down(name, code) {
  return function (props) {
    var next = getNextBreakpoint(name, props);
    var previous = getPreviousBreakpoint(name, props);
    var value = getBreakpointMax(previous, props);
    if (next === null) return code;
    return (0, _styledComponents.css)(_templateObject2(), value, code);
  };
};

exports.down = down;

var between = function between(lower, upper, code) {
  return function (props) {
    var min = getBreakpointMin(lower, props);
    var max = getBreakpointMax(upper, props);
    var upperPrevious = getPreviousBreakpoint(upper, props);
    var previousMax = getBreakpointMax(upperPrevious, props);

    if (min !== null && max !== null) {
      return (0, _styledComponents.css)(_templateObject3(), min, previousMax, code);
    }

    if (max === null) return up(lower, code)(props);
    if (min === null) return down(upper, code)(props);
    return null;
  };
};

exports.between = between;

var th = function th(name, modifier) {
  if (modifier === void 0) {
    modifier = function modifier(x) {
      return x;
    };
  }

  return function (props) {
    function run(fn) {
      var next = fn(props);
      if (typeof next === 'undefined') throw new Error("\"" + name + "\" not found in theme");
      if (typeof next === 'function') return run(next);
      return next;
    }

    var result = run(function (p) {
      return p.theme[name];
    });
    return modifier(result);
  };
};

exports.th = th;

var mixin = function mixin(name) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return function (props) {
    return props.theme[name](props).apply(void 0, args);
  };
};

exports.mixin = mixin;

var resolveUnit = function resolveUnit(value) {
  return typeof value === 'number' ? value + "px" : value;
};

exports.resolveUnit = resolveUnit;

var calc = function calc(value, fn) {
  var _String$match = String(value).match(/([\d.]+)\s*(.*)/),
      num = _String$match[1],
      unit = _String$match[2];

  return "" + fn(Number(num)) + (unit || 'px');
};

exports.calc = calc;